<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
    <title>Document</title>
    <link rel="stylesheet" href="./index.css">
    <!-- <script src="./jq.js"></script> -->
</head>

<body>
    <!-- <div class="barrage">
        <div class="row">
           
        </div>
    </div> -->
    <div class="inputView">
        <!-- <input class="remarkMessage" /> --><button class="btn">点击发送</button> 
    </div>
    <!-- <video src="./HTML5的前世今生.mp4" controls></video> -->
    <!-- <video src="./html.mp4" controls></video>  -->
</body>
<script>
  
 window.onload = function(){

    function verify(x) {
         console.log(x)
     }

    //  function debounce(fn, wait, value) {// wait 时间内多次触发，仅执行第一次
    //      let timer;
    //      return function () {
    //          let that = this;
    //          if (timer) clearTimeout(timer);
    //          let execTimer = !timer;
    //          timer = setTimeout(() => {
    //              timer = null
    //          }, wait);
    //          if (execTimer) fn.call(that, value)    
    //      }
    //  } 
    let timer;     //  适用方式一
    function  debounce(fn, wait, value) {// wait 时间内多次触发，仅执行第一次  
        let that = this;
        if (timer) clearTimeout(timer);
        let execTimer = !timer;
        timer = setTimeout(() => {
            timer = null  
        }, wait);
        if (execTimer) fn.call(that, value)    
     }
    //需求：   连续点击多次btn, 仅执行第一次，间隔1S
    //问题：   方式二可行，方式一不行；他们的区别？问题存在原因？
     //  方式一
     document.querySelector(".btn").addEventListener('click', function(){
          debounce(verify, 1000, "up")
     })

     // 方式二
    //document.querySelector(".btn").addEventListener('click', debounce(verify, 1000,"up"))

    //  方式三，同方式二一样可行，但是获取参数？？？
    // document.querySelector(".btn").addEventListener('click', {
    //     handleEvent:debounce(verify, 1000, "up")
    // })
 /*

document.querySelector(".btn") .onclick = function () {
        let value = document.querySelector(".remarkMessage").value;
}
function deBounce(fn,wait,value){
    console.log("1")
    let timer;
    return function(){
        console.log("2")
        let that = this;
        let  args = Array.from(arguments)
        if(timer) clearTimeout(timer);
        let execTimer = !timer;
        if(execTimer)
            fn.apply(that,args)
        timer = setTimeout(() => {
            time = null
        }, wait);
    }
}
*/


/*

    function sendMessage(value){     // 提交数据
        let xmlHR;
        if(window.XMLHttpRequest){
            xmlHR = new XMLHttpRequest();
        } else {
            xmlHR = new ActiveXObject("Microsoft.XMLHTTP")
        }
        xmlHR.onreadystatechange=function()
	   {
		    if (xmlHR.readyState==4 && xmlHR.status==200)
		    {
              let result = JSON.parse(xmlHR.responseText);
               console.log(result.message)    
	    	}
	    }
        xmlHR.open("Post","/barrage",true)
        xmlHR.setRequestHeader('Content-type', 'application/json');
        console.log(value)
        let data ={message :value}
        xmlHR.send(JSON.stringify(data));
    }
 
   



    // 根据数据创建节点；
    function createBarrage(value, id) {
        let span = document.createElement("span");
        span.innerHTML = value;
        span.setAttribute("m-id", id);
        document.querySelector(".row").appendChild(span);
        return span;
    }
    // 节点做动画
    function barrageAnimate(obj) {
        let newLoca = parseInt(obj.style.left) || 0;
        newLoca++
        if (newLoca > 680) {
            console.log("超出屏幕");
            // 删除节点；
            obj.parentNode.removeChild(obj);
        } else {
            obj.style.left = newLoca + "px";
            requestAnimationFrame(function () {
                barrageAnimate(obj);
            })
        }
    }

*/
    
 }
</script>

</html>